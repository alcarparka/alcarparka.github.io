<!DOCTYPE html>
<html>
<title>Defense Against the Dark Arts Page</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">
<style>
body,h1,h2,h3,h4,h5 {font-family: "Raleway", sans-serif}
</style>
<body class="w3-light-grey">

<div class="w3-content" style="max-width:1400px">

<header class="w3-container w3-center w3-padding-32"> 
  <h1><b>CS373: Defense Against the Dark Arts</b></h1>
  <p>Welcome to the page of <span class="w3-tag">Alexandra Carper</span></p>
</header>

<!-- Grid -->
<div class="w3-row">

<!-- Blog entries -->
<div class="w3-col l8 s12">
  <!-- Blog entry -->
  <div class="w3-card-4 w3-margin w3-white">
      <div class="w3-container">
      <h3><b>Write Ups Completed</b></h3>
      </div>

    <div class="w3-container">
      <p>Homework 1</p>
	    <p>Homework 2</p>
	    <p>Homework 3</p>
	   <a href="week4.html">Homework 4</a>
    </div>
  </div>
  <hr>

  <!-- Blog entry -->
  <div class="w3-card-4 w3-margin w3-white">
    <div class="w3-container">
      <h3><b>Homework Write Ups</b></h3>
      <h5>Week 1 <span class="w3-opacity">June 30, 2019</span></h5>
    </div>

    <div class="w3-container">
      <p>This week, we went over the basics of malware. The introduction to malware included why malware exists, who is behind it, and what their motivations are. When I read through the main motivations of hackers, I found it easy to think of examples of each motivation. For instance, the recon/spying motivation reminded me of the Russian hacking and influence in the 2016 United States election. I also thought it was valuable to learn the main roles as an anti-malware researcher. To be an effective anti-malware researcher, one must be able to understand and describe the threat, which is what made this week's homework so valuable. Looking at the malware with several different tools made it easier to understand what the evil.exe file was trying to accomplish. <br><br>
	We also learned several malware-related definitions, such as white, which is equivalent to clean, and the meaning of a "goat", which I had never heard of before. The goat something you sacrifice to learn more about a certain instance of malware. I spent a good deal of time thinking about the fact that the user is the biggest infection vector, and I reflected back to my security training at my job. The security training we were required to complete focused mostly on what you can do as a user to prevent infections from malicious software that is spread through channels such as email.<br><br>
	Many of the concepts within the first lecture were familiar to me already. For instance, I know that Trojan horses trick users into opening them because they appear to be receiving legitimate software, or files from a legitimate source, and I also know that spyware collects personal information without the user's knowledge as if it's "spying" on you. But not all concepts were familiar, and I thought the name deciphering was extremely valuable because I was not aware of the naming conventions of malware. I feel that there is a lack of information when it comes to the general public being able to identify files that may be malware on their computer. <br><br>
	One thing I have always been interested in learning more about is the U.S. Military's relationship with cybersecurity. I thought it was especially interesting to learn that the U.S. Air-force analysts created the term "Advanced Persistent Threats" in 2006 to describe the aspects of attackers that represent their profile, intent, and structure. I learned that the kill-chain related to this term involves several steps: Reconnaissance, Weaponization, Delivery, Exploitation, Installation, Command and Control, and finally Actions on Objectives. 
<br><br>	In summary, I learned several new malware terms and definitions, naming conventions, online analysis services and tools, the basics of replication and setup, and I performed some sample execution within the VM with the recommended tools. One of the most valuable things I learned this week is that naming conventions of malware are extremely similar to the Windows naming conventions. VirusTotal and WepaWet are valuable tools for analysis of all kinds of malware, and replication is also a valuable strategy for analyzing malware. The best way to replicate for analysis is keeping anti-virus software or firewalls off your computer so that the malware can break out and you can study it. There was much more interesting information within the lectures this week, but these were the items that I thought were most interesting.</p>
      
<div class="w3-container">
      <h5>Week 2 <span class="w3-opacity">July 7, 2019</span></h5>
    </div>

    <div class="w3-container">
      <p>This week, we went over advanced forensics in cybersecurity. We learned about IR and forensics methods, core Windows forensic techniques, Windows Registry Primer, file and directory analysis, data recovery with PhotoRec, and we performed four labs. Forensic computing is, "the process of identifying, preserving, analyzing and presenting digital evidence in a manner that is legally acceptable." In this context, evidence is anything you can use to prove or disprove a fact. We started out by learning more about some basic evidence handling procedures and the Instant Response process. The Instant Response process starts with an incidence response team, moving on to incident detection, initial response, formulating a response, moving through a legal
	    phase that includes investigating through data collection and forensic analysis, documenting findings in the administrative phase and then remediation and evaluation.<br><br>
	    We also learned that physical memory is the short-term memory of a computer that experiences a rapid decay of information as soon as the memory module is disconnected from power and clock sources. When we dump the memory, there is the potential to obtain all running processes at the time of the memory snapshot, all loaded modules and dynamic link libraries, all running device drivers, and much more. It was interesting to learn that every process within Windows is assigned 4GiB of Virtual Memory, split into halves. When memory is dumped, analyzing sysinternals' strings is a difficult way to interpret events. There is no context and the strings are difficult to interpret what string is associated with which program.<br><br>
	    Two of the major tools we learned about this week were Volatility and Yara. Volatility is an advanced memory forensics framework written in Python. With Volatility you can write and create your own plugins, which are useful for malware detection. We used Volatility within the labs this week along with several plugins. Yara is a tool designed to help malware researchers identify and classify malware samples. Yarascan is a plugin for Volatility that can scan a memory image for a yara signature. When used with a rule file or with a definition of what you are looking for, Yarascan can narrow down the search to find specific items. <br><br>
	    Within the lab, we demonstrated several Volatility plugin examples, such as dlllist -p <pid>, netscan
	      deskscan, and getsids. The command to run volatility with these plugins on the memory dump is volatility.exe -f <name of memory dump> plugin. We used imageinfo to image the date and time from the machine with the memory dump. The -h flag is the help option for Volatility. One example of the result of running the plugins was running the command "volatility-2.3.1.standalone.exe -f memdump_sample1.mem --profile=Win7SP0x86 psscan". This command displays processes with parent IDs, which can be valuable for tracing malware back to the source.<br><br>
	      Within the Core Windows Forensics section we learned about Windows Registry Primer. The idea behind this is that everything done in Windows refers to or is recorded into the Registry. RegMon (Sysinternals) can be used to display registry activity in real time, which is valuable because the Registry is referenced in one way or another with every action taken by the user. One tool recommended in the lectures was Regripper, which is a forensic investigation tool on the Registry. I was eager to learn more about the Registry since last week's lab, where Registry keys kept popping up within Process Monitor. One recommendation we received in this week's lectures in order to help us see the Registry as one unified "file system" is opening the Registry Editor by typing the command "regedit" in the run window. The five most hierarchal folders are called 'hives' and begin with 'HKEY',
	      which I was very familiar with seeing within the tools from last week's labs. The two real hives that can be seen are HKEY_USERS (HKU) and HKEY_LOCAL_MACHINE (HKLM). We call these the 'real' hives because the other three are shortcuts or aliases to branches within one of the two previously mentioned hives. Each hive is composed of keys, which contain values and subkeys. The values of the keys are the names of certain items within a key; these help identify specific values related to the operating system or applications depending on that value.<br><br>
	      Other key artifacts related to forensic computing are System Restore Points, Pagefile.sys, the hibernation file, crash-dump files, LNK files, and shell-bag. The lectures also discussed AutoRun locations, MRU lists, UserAssist, Geolocation through wired and wireless networks, USB devices, and Internet Explorer as tools to gather evidence about the Registry for your forensics log. One term that was emphasized within the lectures was the MFT, or the Master-file table. This table is relevant because the timing of events, or timeline, typically becomes the core of the investigation. Creation and modify times that are set around the period of file access can help a forensic investigator gain insight into the actions that took place on the system and the files the attackers touched. A larger picture emerges once you
	      correlate this evidence with other time stamped files like Windows events logs. Volatility is one tool that allows you to create a timeline, along with $MFT, Reg-ripper, and timeliner, which gives you an overview of what happens in the system. MFT parser also gives you a history of what happened on the system. <br><br>
	      Next, a forensic investigator can look for relevant files (such as pagefile.sys, index.dat, etc.), Windows event logs, application configuration files and logs, the prefetch folder, and evidence of malware when browsing the offline filesystem. The system and application event logs are very useful, with many tools available for extracting them. This also goes for security and DNS logs. We can also analyze the IIS/webserver/FTP logs/URLScan, which is useful to detect webapp exploiting, as well as the Windows Firewall log with %windir%\pfirewall.log. Dr. Watson logs contain information about processes running when an application crashed, and setupapi.log contains information about installation of applications and devices. schedlgu.txt contains information about scheduled tasks, which would have been helpful for the first lab, as one main piece of evidence was that the malware scheduled tasks every thirty minutes in the future. 
	      The last set of logs that were recommended for file and directory analysis were the antivirus/IDS/IAS/ISA Server/ logs. <br><br>
	      The final topic we covered this week was data recovery. This process recovers files or data deleted or in slack from the system. Investigators can identify when the files were deleted, look for fragments and unrecoverable data, and recover pertinent files, including images and emails. This was relevant for the last tool we learned and demonstrated, PhotoRec. PhotoRec carves out files in an image based on headers. The output directory specified will contain all the files recovered. <br><br>
	      Screenshots from the labs this week and the relevant information are included in the following zip file: <a href="/Screenshots2.zip" download>Screenshots Week 2</a></p>
	      
<div class="w3-container">
      <h5>Week 3 <span class="w3-opacity">July 14, 2019</span></h5>
    </div>

    <div class="w3-container">
	    <p>Concepts Introduced This Week<br><br></p>
	    <p>Malware Defense was the topic under focus this week, and this included how to detect, block and remove malware threats. Some of the most important concepts of malware defense are the Malware Attack Graph, using YARA to write one’s own malware defense rules, and using Cuckoo, which is a tool that allows one to analyze malware. </p>
	    <p>The Malware Attack Graph was a major concept covered in the lectures. There are four phases associated with this attack graph, first contact, local execution, establish presence, and malicious activity. First contact refers to the concept of hackers having the ability to reach their targets, and there are several ways of achieving this. As displayed within the graph, these methods of communication and targeting can occur through physical media, such as using USB drives paired with social engineering, untrusted or trusted websites, physical access, remote exploit using servers, direct messaging, and the “man in the middle” method through wired and wireless access. Directly messaging the victim can occur through channels such as Facebook, IM and email, and the attacker will usually attempt to trick the victim into giving out personal information or confidential files. For example, an attacker may pretend to be the CEO of an employee’s company asking the employee to wire money to a certain account or send them files. Attackers can utilize physical media by either leaving USB drives in certain places and waiting for someone to take the bait or by using social engineering to gain access to a secure building and inserting the USB drive into a device themselves. Another method attackers use is called a “watering hole attack”, which involves attackers targeting a specific group of people using the websites they visit on a daily or weekly basis, infecting these websites and causing several people to be affected at once. Attackers also have the ability to simply steal a victim’s laptop or intercept their information via a shared network or server, gaining access to their information without truly interacting with them. </p>
	    <p>Local execution has to do with executing the malware on the victim’s local machine after initial contact with the victim has been achieved. There are several ways to influence or trick the user into executing this malicious content on his or her local machine. Phishing consists of any attack where a threat actor attempts to pass themselves off as another entity in order to exploit or gain access via the user; however, there are certain subsets of phishing. For example, spear-phishing is targeted phishing toward a particular user, with the attacker knowing that the user has some information the attacker needs. The attacker can make emails look like they came from companies they do business with and get a user to open a file. Attackers use tools like Metasploit, which allows them to take an application and a PDF file they wrote and attach the malicious code to this PDF file. When the file is opened by the victim, the malicious code will be executed on the local machine. This execution involves the attacker setting up a shell that opens up a back door on the user’s machine, which can perform actions like calling out to a server the attacker has previously set up to be listening for a shell connection. Other than phishing attacks and convincing the user to run an executable, attackers can target file format and browser vulnerabilities by crafting malicious files that trigger flaws in applications, such as buffer overflow. Attackers can create a single malicious PDF using Adobe Acrobat that is compatible with Windows, Mac and Linux systems, which allows them to even cross platforms. </p>
	    <p>The attacker establishing a presence on the local machine involves multiple steps once the malware has been executed. The first step is “blend in or hide”. This step involves hiding from the user or making malware appear legitimate so he or she does not know that the attacker has accessed their local machine. Attackers can accomplish this by making their malicious files appear to be legitimate operating system files. They use tricks like naming the files with the typical operating system syntax, changing the timestamp on the file to hide the fact that the files have just recently been installed, and signing the files to make them appear legitimate (signed files are more likely to be innocent than malicious). Rootkits and bootkits are often used to hide the installation of files and execution of processes. Rootkits allow someone to gain access and control over a computer without the owner’s knowledge. Once a rootkit has been installed, the controller is able to remotely execute files and alter system configurations on the user’s machine. It can also gain access to log files and spy on the usage of the owner. Alternatively, bootkits are an advanced version of a rootkit that can modify the master boot record or volume boot record to execute malicious code and transfer control within Windows. The bootkit has the ability to remain active in the system memory from protected mode so that even a system reboot will not have an effect.</p>
	    <p>This leads into the persist step of establish presence. The attacker can blend in and hide, but they also want their malware to persist through a system reboot. As mentioned, a bootkit can be an effective tool to facilitate the persistence of malware through a system reboot, but there are other ways to achieve this. Attackers can also give malware the ability to take over the Windows startup through APPINIT, Winlogon, Run keys, the startup folder, etc. They can use techniques such as DLL search order hijacking, in which they place a malicious DLL with the same name as an ambiguously specified DLL within a location that Windows will search before the legitimate DLL, or run a shell extension handler. Scheduling tasks to run malware, like what we observed within the first lab, or using autorun.inf to maintain malware execution are also effective methods of persistence. Autorun.inf has the executable that is to be opened expressed in a few different ways. If the file is on the root of the drive that Windows is mounting, autorun.inf would arbitrarily execute the path. The Autorun program is a tool that can help with triaging, or discovering what actions the malicious software took on your local machine. Proxy configurations are also used to attack by utilizing the network settings within Windows such that when the network is available the attacker can provide an IP or domain name designate where to retrieve the configuration file from. </p>
	    <p>Harvesting information is the next step in establishing a presence. In this step, attackers can enumerate documents, steal passwords, emails, or process information using a hook, such as a browser, keylogger, or screen scraper. A keylogger is a piece of software that tracks or logs the keys struck on your keyboard, typically without the user’s knowledge. A screen scraper is a form of malware that is capable of taking screenshots or gathering data from what is displayed on the user’s desktop in order to send information back to the attacker. The data that is harvested is then parsed for information such as passwords, logged, and then used for the phone home step. A high-profile threat that occurred recently with Home Depot is the RAM scraping credit card threat. The attackers were able to run an arbitrary executable that enumerated all of the processes within Home Depot’s system, doing a reg ex and trying to match what looked like information that tracked to credit card data. Then, it was just a matter of redirecting out to a file and getting the file out to the attackers’ machine. </p>
	    <p>The phone home step is the last step for establishing a presence. Phoning home involves taking the information that was harvested previously and sending it back to the attacker. This can be done via network protocols such as HTTP, HTTPS, FTP, TOR, or even using SMTP for email; however the web protocols are the most common means to get information from a commanded machine. The last phase within the Attack Graph was the malicious activity phase, which is self-explanatory, as this is the phase in which the malicious activity occurs.</p>
	    <p>Another important concept is the popular technologies in malware defense. Heavy emphasis is placed on the fact that it is very hard to build one technology that has the ability to block everything. The most effective strategy here is building a layered defense. These include email reputation, message reputation, network, URL, and network IPF. All of these technologies are dependent on each other, and users can utilize the combined intelligence of all the layers to get a more holistic view on a certain threat. Relative to local execution, banks have been known to give their employees a code picture that allows them to know what they can trust and should not trust. Sometimes RSA tokens are also used as a secondary ID. Antivirus software is critical to defending against an attacker establishing a presence, and the attacker will often try to disable security software or turn off updates on security software so their malware can persist. Within the malicious activity phase, defense involves harvesting information off the box. Data loss prevention is important here for looking on the box and in the network to see what is going out via the network. Other defense tools that are important to this phase are anti-keyloggers, screen-scraping, and botnet detection for network intrusion prevention to observe what endpoints are connecting to what IPs on what frequency. Within the diagram of popular technologies, we can see the most popular at the perimeter are the network firewall and network intrusion prevention. The next layer is message, network, and web reputation. The inner layer is comprised of a network interface on the host as well as everything behind that interface, which includes the host IPS, access control, and anti-malware. The endpoint dependencies for malware defense are the point product, the scanner core, the engine, and the content. The point product is usually the virus scan enterprise or host intrusion prevention. The scanner core can be something such as a rootkit scanner or message reputation and network scanning. The scanner core knows how to handle different types of information, and it has a central host for scan cores that keeps track of the cache and is optimized for performance. The interface is then the engine and the engine consumes the content. The anti-malware features within malware defense include traditional file scanning (OAS, ODS), using the registry and cookies, cloud scanning to deliver daily and hourly content in the could updated in real-time, memory scanning, scripts, heuristics, decomposition to look inside a container and scan the components for a specific file format, and configuration, including exclusions, sensitivity, reporting, etc. </p>
	    <p>One tool that is used heavily by malware researchers is YARA, which is described as the “pattern-matching Swiss army knife for malware researchers”. This tool allows malware researchers to identify and classify malware by tuning the scanning of files within memory. The syntax of YARA is straightforward, as it is made up of rules and simple logic. YARA gives users without the ability to access to scan programs a way to perform scanning on their own, with a language side and a scanner side. Users can write rules as sets of strings with certain conditions, byte patterns, and Boolean operators to report any files that match these conditions. Strings can be followed by such conditions as case insensitivity, hexadecimal string conditions, or Boolean, relational, arithmetic, and bitwise operators. Good generic rules for YARA typically have fewer strings and conditions; longer YARA signatures make the conditions stronger, but are too specific and do not allow for variance in the future. </p>
	    <p>To summarize signatures, signature creation and malware analysis often go hand in hand. Automated signatures account for the majority of content, and automated analysis is of high importance. Machine learning is starting to play more of a role in analysis and signature focus is moving away from just files. Crafted signatures that are generic and original create the most proactive signatures for analysis. In addition, the advantages of anti-malware automation are scale, consistency and the fact that performance is less of a concern. One of the biggest disadvantages of this automation is that it is out of context, specifically traditional backend automation, because most malware is aware of the virtual machine. They are also prone to evasion, for example your Windows license ID can give away the fact that the user is using a virtual machine. Finally, they are prone to probing and denial of service attacks. </p>
	    <p>Another tool that allows users to understand what actions a file performs when it is executed in an isolated environment is Cuckoo. Cuckoo is an automated malware analysis tool that provided process traces, memory dumps, network traffic, file creation/deletion/download tracking, and snapshots of the desktop whilst malware is executing. Cuckoo can analyze a wide variety of malicious files, such as executables, office documents, pdf files, and emails, and it can also investigate malicious websites under Windows, Linux, macOS, and Android virtualized environments. When Cuckoo traces the general behavior of the malicious file, it is able to distill the information into a high-level view with signatures that almost any user is able to understand. It can also perform advanced memory analysis through Volatility, which was covered last week, as well as on a process memory granularity using YARA. </p>
	    <p>Lab Blog Post</p>
	    <p>I chose to analyze the first malware sample within the given samples, which had the hash of 068D5B62254DC82F3697847C16710B7. Within the Cuckoo logs we can see that the malware stores a created file named wm.ime within system32 when executed. As we know, the attackers' intent when storing this file in this specific location is to hide it. When researched further, we find that a file with an .ime extension is an Input Method Editor, which is primarily associated with Global Input Method Editor by Microsoft. This is typically a program that allows the computer to enter more complex characters and symbols, such as Chinese characters, using the standard keyboard. Because the file is stored as an input method, we can assume that this malware may be a type of keylogger. </p>
	    <p>Next, we can use FileInsight to analyze the strings within the malware. When we analyze the strings we can see certain locations with file names that look foreign, such as GetTuPian.asp and background_mibaoshouji.png. This gives us more evidence that this may be a piece of Chinese malware. Furthermore, the ValueName seems to be changed to zh-cn within the Cuckoo logs, otherwise known as the language code for Simplified Chinese. The strings also tell us that an HTTP request is being made, which seems out of the ordinary for the type of file that is being installed, and the first string that appears within the file is “MZKERNEL32.DLL”, which is widely known as a type of Trojan horse. </p>
	    <p>If we take a further look into the Cuckoo logs, we can see that the malware also reads files named sortdefault.nls and kbdus.dll, adds an input method to the registry, adds this new method to the HKEY_CURRENT_USER\Keyboard Layout\Preload location, and then writes a batch script to the C drive. Before finishing execution, these files, along with the original malware file, seem to be deleted to hide the fact they were there in the first place. </p>
	    <p>Next, we can execute the malware to see what affect it has on the virtual machine. Once the malware is installed on the virtual machine, and after investigating the changes it made to the machine, we can see that a language option appears within the system tray with the option to use either English or Chinese. We also know from our previous observations that, regardless of the original malware file being deleted, our machine is still infected because the wm.ime file appears within the system32 directory. </p>
	    Screenshots from the labs this week, relevant YARA signatures and code samples, and the YARA signature I wrote for the lab (named YARA signature.jpg) are included in the following zip file: <a href="/Screenshots3.zip" download>Screenshots Week 3</a></p>
    </div>
  </div>
</div>

<div class="w3-col l4">
  <div class="w3-card w3-margin w3-margin-top">
    <div class="w3-container w3-white">
      <h4><b>Alexandra Carper</b></h4>
      <p>This page was created for Weekly Writeups for Defense Against the Dark Arts</p>
    </div>
  </div>
 
  

</div>

</div><br>

</div>

<footer>
</footer>

</body>
</html>
