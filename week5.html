<!DOCTYPE html>
<html>
<title>Defense Against the Dark Arts Page</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">
<style>
body,h1,h2,h3,h4,h5 {font-family: "Raleway", sans-serif}
</style>
<body class="w3-light-grey">

<div class="w3-content" style="max-width:1400px">

<header class="w3-container w3-center w3-padding-32"> 
  <h1><b>Week 5 Write Up</b></h1>
  <p>Welcome to the page of <span class="w3-tag">Alexandra Carper</span></p>
</header>

<!-- Grid -->
<div class="w3-row">

<!-- Blog entries -->
<div class="w3-col l8 s12">
  <!-- Blog entry -->
  <hr>

  <!-- Blog entry -->
  <div class="w3-card-4 w3-margin w3-white">
    <div class="w3-container">
      <h3><b>Homework Write Up</b></h3>
    </div>

    <div class="w3-container">
      <p></p>
      
<div class="w3-container">
      <h5>Week 5 <span class="w3-opacity">July 28, 2019</span></h5>
      <p> The focus of this week was rootkits, user mode memory basics, kernel memory basics, and hooking basics. The goal was to understand the concepts of stealth by means of memory manipulation, as well as debugging and exploring various stealth techniques. Between 2006 and 2012, rootkits were peaking, and majority of attackers were using the. None of the antivirus software at the time had the opportunity to catch up quick enough to hinder attackers at the time, but when antivirus software did catch up, there was some decline in the use of rootkits. The use of rootkits spawned from malware authors’ inherent desire to hide, which is why these techniques are still used today.</p>
      <p> A rootkit is a piece of malware that actively conceals its existence and actions from users and system processes. Approximately 10% of current malware uses rootkits, and these rootkits are most prevalent in 32-bit Windows systems; there are only a handful of families so far for 64-bit systems. The focus this week was on rootkits because they are one of the best ways to learn about kernel security challenges. While it is challenging for rootkits to enter a 64-bit operating system kernel, they can infiltrate this kernel by bypassing driver signing checks using testsigning mode, modifying the Windows boot path with the master boot record (MBR), using kernel exploits in the Windows kernel or third-party drivers, or stealing valid digital signatures. </p>
      <p>	In any modern operating system, the CPU runs in two distinctive modes: user mode and kernel mode. Applications run in the user mode area, at some point transferring controls to do anything useful with the hardware. This transfer of control occurs when user mode applications call APIs that tell the kernel what to do. The user layer is comprised of mostly .exe and .dll files, while the kernel layer is comprised of .sys files, or device drivers such as for webcams. All of these files are considered PE files, or portable-executable files. Most rootkits prefer to be in the kernel mode because it gives them full power to manipulate anything in the system. Once a device driver is installed, the rootkit can do anything on the system, whereas application files are restricted. </p>
      <p>	Kernel memory is a flat memory model with no security separation. Here, the goal is to stop device drivers from being loaded in the first place because, once they are loaded, the attackers are on the same level field as the defenders. Any kernel driver can access any part of memory, which is composed of the Windows kernel (ntoskrnl.exe), as well as driver code. Many important structures are within the kernel memory that are prime targets for stealth, including SSDT, IRP, IDT, etc.</p>
      <p>	One of the first tools that was briefly introduced was RegShot. RegShot is a system diff tool that involves the user running the tool, then running the malware, and then running the tool a second time. When the tool is run the second time, RegShot shows you what actions the malware performed. Within Lab 1, a few other tools were used as well, along with the WinDbg tool that was introduced last week. Within WinDbg, a few more commands were presented, including “dir *”, “dir *.*”, and “dir *.sys”. “dir *” was used to see what was in the analyzer folder, and “dir *.sys” was used to view a file sitting in the folder that was not part of the directory commands. A tool called Tuluka, which is a third party tool that performs a few extra actions to find rootkits, was introduced as well. With this tool, we can “Sort by Suspicious”, which shows items in red as long as the bin init.sys is hidden on your computer. With this tool we viewed the NtQueryDirectoryFile, which is the particular file that gets called when you use the command “dir *.*”. The command application is calling the user mode API, which passes parameters to the kernel, and NtQuery gets called when control is transferred to the kernel. This is where “hooking” occurs. API hooking is a technique used to instrument and modify the behavior and flow of API calls. The three significant APIs in this case are NtQueryDirectoryFile, NtEnumerateValueKey, and NtQuerySystemInformation. NtQueryDirectoryFile creates a directory and enumerates it, NtEnumerateValueKey helps enumerate registry values, and NtQuerySystemInformation gives you information about the system and enumerates the processes. The Tuluka tool also provides rows called “Original” and “Current”, which display the pointers in the kernel that are responsible for the enumeration of kernel APIs. We can view these to determine whether or not a rootkit has swapped an old pointer with a new pointer and is filtering the files secretly. </p>
      <p>	Another tool introduced this week was LiveKD, a live debugger that has various commands and is capable of reading Windows kernel memory and displaying the output on the shell. One important piece of information needed before using this tool is that an address space above eight and seven zeroes is considered to be a kernel space. The “u” command can be used within this tool to unassembled, just like the command that is used within WinDbg. When using either the original or the current address found within the Tuluka tool with this command, we can see what is contained in each location respectively, which can be useful in a case of hooking.  Using the current address would allow the user to view the new code that is in that location. It was relevant in this case to learn that the new malicious code sitting here must let go of what it does not want, otherwise it would raise suspicion; therefore, it must call back to the original address somehow. Two other relevant commands within this tool were “.cls”, which clears the screen, and “lm”, which lists all the modules loaded in the kernel memory with their respective addresses. With Tuluka, we can also dump memory and view it using a FileInsight tool. Finally, the “dps nt!kiServiceTable L191” command lists system APIs in a table, including addresses, where the code sits, and the name of the API. This table is called an SSDT, or System Service Descriptor Table, and it lists all the system level APIs that are available for use. </p>
      <p>	Tuluka has a valuable function that allows us to fix this kind of hooking instance, the “Restore Service” feature. This feature patches the address back to the original location because it knows where the original address is and how to patch it. Since Windows constantly calls the NtQueryDirectoryFile, patching must be cautious so that no other thread is calling the function at the same time. Often, defenders will dynamically read the kernel code of the bad actor because eventually the bad actor must call back to the original location. Defenders try to anticipate which call is going back to the original location and dynamically patch the memory once this call is found. </p>
      <p>	We transitioned into some low-level concepts related to the operating system this week, such as the basic concepts of threads. A thread is the smallest unit of execution within an operating system. Each program is written in a high-level language, which gets converted into assembly to run and execute on the machine. This code is translated into opcodes, and a binary sequence gets loaded into RAM before execution and relocations are made. The BUS transfers the code to the CPU, which has an instruction pipeline fetching instructions and executing these instructions. The CPU has basic things like math processor execution engines, it can execute millions of instructions very fast, and it can have multiple threads per application. These multiple threads are managed by a thread scheduler that does thread scheduling for us. The scheduler uses time slices to determine how long a thread can execute, looks at the high priority threads and puts them into the CPU to execute, and boosts the priority of the threads that are currently waiting. Most applications are multi-threaded; for example, you would not need to wait on your printer before you perform any other tasks on your machine after clicking “Print”. </p>
      <p>	Regarding multithreading, two different features can be offered through the CPU. CPU hyperthreading involves two instruction pipelines, with everything else remaining the same. Hyperthreading selectively uses threads, with two logical CPU cores sharing physical execution resources. This can speed a system up, but not as much as actually using two cores. In contrast, the DUAL core feature uses a single chip (package) to duplicate all the functionality within the package, which allows the CPU to process much faster. </p>
      <p>	There are a few important concepts of a thread that were explained, the thread context, thread stack, thread environment block (TEB), thread scheduling, and the thread-process relationship. The thread context, for example, relates to a situation in which a thread scheduler is scheduling one thread and the other thread is waiting. The other thread must save work somehow (or the context it was in), and this context gets saved in memory while the other thread is executed. This context is eventually restored, as it is needed for the thread to run and execute instructions. The thread context stores all the related register values of the thread, and during execution register values are stored in the CPU. The thread object defines a thread, and kernel objects are data structures defined by the operating system to describe various operating system constructs, a thread being one such construct. The TEB, ThreadStack, Context, Priority, State, etc. are all defined within this struct. To view the thread object, we can use the WinDbg command “KD>dt_KTHREAD”, which shows all things within the thread structure. </p>
      <p>	Each thread has its own stack, and we can used WinDbg to examine these stacks and the TEB. The user mode stack is used for the thread’s function calls and local variables, whereas the kernel stack is used when control is transferred from the user to the kernel; here, the data is copied for security purposes. The command “KD>DT_TEB” within WinDbg shows the thread environment block, which contains threat specific information like exception handling and TLS. </p>
      <p>	Process Hacker was another tool that was introduced to examine process memory. Processes are implemented as objects, and an executable process may contain one or more threads. A process includes an object table that has handles to other objects known to the process, and each process needs at least one thread to execute. This object table has handles to various things, and each handle give the object table a way to find further objects. Process Hacker is similar to Process Explorer, and we can use this tool to look at the properties of each process. Memory is laid out starting at address 0, and the tool walks through the virtual memory of the process and identifies some attributes about the memory, including the amount of free memory, the address of committed memory, protections (readable/writeable), images that host the binary image of a .exe file, and heap memory enumerated. Every process within the Windows OS 32-bit has up to 4 GB of memory it can allocate to perform tasks. A good indicator of something bad going on within a process is noticing a private page with execute permissions within the Process Hacker tool. This private page has no name, and it can indicate process injection, which is when there is an external application that is running that saw a process being spawned and injected its code externally to control the process. </p>
      <p>	When learning more about hooking, it was explained that there are process sections for every .dll file. These sections include a code section, an import data section, and a Kernel32.dll file that includes basic Windows APIs and functionality needed to get applications to work. The FindNextFile call uses the import data section to translate the address to know where to jump, and the Kernel32.dll implements this functionality. One specific hook in user memory that is notable is called Hacker Defender, which is the father of user mode rootkits. This rootkit replaces the first five bytes of code of the FindNextFile API with a jmp, which jumps to somewhere else in process memory (a bad address). Once this is done, it restores and calls the next instruction of the FindNextFile API. There are also several locations within kernel memory that are open for rootkits to modify and put their pointers in so their code is called first instead. Ultimately, all these pointers need to call into the NtosKrnl.exe or Legitimate Device Driver. Here, the rootkit hijacks the functionality and filters results through it. Families of rookits that have done this include Bagle, Srizbi, Apropos, and Spam-Mailbot. We can detect these kinds of rootkits by defining within the system that we trust a particular device driver, since pointers need to point in areas that we trust, like the kernel or legitimate device driver. In addition, heuristics have the ability to trigger an alarm that a detour was found outside of a trusted area. </p>
      <p>	Setting breakpoints within the debugger is a way to examine the program at a certain state to view the instructions and contents of variables. The “bp” command can be used in WinDbg with an address to set a breakpoint in a specific location. In addition, the “bl” command lists the breakpoints that have been set within the program. By examining the breakpoints within the third lab, we discovered and additional entry in the call stack, and we used the Dissassembly feature to see the wininit code. </p>
      <p>	There are several techniques used by various rootkits, including inline hooks, import table hooks, direct kernel object manipulation, inline hooks, IRP hooks, SSDT hooks, IDT hooks, Sysenter hooks, filter driver, and MBR. For example, an inline hook is if someone were to modify the function rather than the table during their attack. Bootkits are another technique of stealth as well, utilizing the system boot process to attack. There are many steps involved in the system boot process before the operating system kernel is loaded. Within this process, the attackers intend to load the malware before the operating system kernel is loaded. This way, the malware bypasses the operating system security checks, which is the behavior of many bootkits. Microsoft intended to avoid this situation by releasing a secure boot that verifies the digital signature at each step of the boot process and is much more stringent. Unfortunately, this breaks some legacy tools that were non-conformant though. </p>
      <p>	Another important topic this week was the master boot record (MBR). The typical MBR pattern ends with two bytes, 55 hex and AA hex. The StealthMBR malware that installs a kernel rootkit via the MBR appeared within 2006 to 2007, infecting the MBR and giving control to the rootkit installer that loaded the rootkit into memory. This malware wrote its code to replace the MBR at sector 0 on the first disk. Generally, from sector 0 to 62, there is an empty blob. This rootkit created a smaller installer blob in sector 61 and saved the original MBR at sector 62. The system boot caused the infection, and when the rootkit was loaded into memory it called the original MBR. As soon as the kernel memory came up, the rootkit module was sitting in the memory. This rootkit was able to fake some data on the disk, and the watcher thread was able to watch the hooks and put them back when they were fixed. When the AV process sent a read request through the disk, the rootkit had the original MBR sitting in memory that read and sent it back. </p>
      <p>	Another simple tool that was presented was SectEdit. With this tool, the user is able to navigate to and open sectors to read contents from the disk. The area above the last two bytes generally contains partition information, and the area before generally is the MBR code. The tool has the ability to export sections, allowing the user to specify the number of sectors and use FileInsight to view the export. </p>
      <p>	The final topic discussed was trends in stealth malware, including file forging, memory forging, self protection, attack AV, disassociating memory from a file-on-disk, removing dependency on files, and untrusting the trusted. File content forging involves overwriting existing files and forging the ‘view’ such that the AV gets the clean view instead of the malicious view. In other words, the rootkits could modify a file, and when you are reading a file they present you a different view. File forging has been used by Tdss.c and ZeroAccess. This method is better than hiding files because hidden files can be located using file-system parsers and comparing file contents is time consuming. Forging, on the other hand, can work well from layers below the file-system (NTFS). Removing dependency on files takes advantage of the fact that scanners based on direct file-system parsers work well. Therefore, having no file in the file-system helps rootkits so they can move malicious code to the boot process using the MBR or VBR, move malicious code to bios, and move encrypted malicious code to raw sectors or as a file. Recent samples of this method include TDSS.d, Whistler, Fisp, Popureb, and Mebromi. </p>
      <p>	These kind of attackers use all kinds of defense components and attack security components to preserve their malware on the victim’s machine. One example is a watcher thread, which can monitor and protect memory hooks and disk changes or rewrite the registry, files, and gain exclusive locks from the system. Self defenses include identifying the AV activity by monitoring the behavior of the process or thread, and if it triggers their behavioral detection logic, the AV is terminated, or untrusting the AV and whitelisting of legitimate applications. In this case, threats establish trust on the essential drivers for the system and everything else could be locked out, so AV now has to find ways to get a chance to even load. </p>
      <p>	The last rootkit example that was presented was the Brazilian Banker rootkit. This rootkit has both x86 and x64 versions, and it uses bcdedit to bypass driver signing requirements through DISABLE_INTEGRITY_CHECKS and TESTSIGNING ON. This rootkit prevents the security tools from loading, using operating system callbacks such as PsSetLoadImageNotifyRoutine, which was provided by Microsoft so that when a new driver is loading, whoever registered for a particular callback could get notified. </p>
	    Screenshots from the materials this week are included in the following zip file: <a href="/Screenshots5.zip" download>Screenshots Week 4</a></p>
    </div>
  </div>
</div>

<div class="w3-col l4">
  <div class="w3-card w3-margin w3-margin-top">
    <div class="w3-container w3-white">
      <h4><b>Alexandra Carper</b></h4>
      <p>This page was created for Weekly Writeups for Defense Against the Dark Arts</p>
    </div>
  </div>
 
  

</div>

</div><br>

</div>

<footer>
</footer>

</body>
</html>
