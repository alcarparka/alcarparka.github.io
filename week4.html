<!DOCTYPE html>
<html>
<title>Defense Against the Dark Arts Page</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">
<style>
body,h1,h2,h3,h4,h5 {font-family: "Raleway", sans-serif}
</style>
<body class="w3-light-grey">

<div class="w3-content" style="max-width:1400px">

<header class="w3-container w3-center w3-padding-32"> 
  <h1><b>Week 4 Write Up</b></h1>
  <p>Welcome to the page of <span class="w3-tag">Alexandra Carper</span></p>
</header>

<!-- Grid -->
<div class="w3-row">

<!-- Blog entries -->
<div class="w3-col l8 s12">
  <!-- Blog entry -->
  <hr>

  <!-- Blog entry -->
  <div class="w3-card-4 w3-margin w3-white">
    <div class="w3-container">
      <h3><b>Homework Write Up</b></h3>
    </div>

    <div class="w3-container">
      <p></p>
      
<div class="w3-container">
      <h5>Week 4 <span class="w3-opacity">July 21, 2019</span></h5>
  <p>The focus of this week was software vulnerabilities and common exploits. The material included concepts about hacking, exploits and WinDBG. The Win-ternals via firehose are especially important because nowadays most of the exploits we observe target the Windows environment. The term “hacking” refers to the act of controlling a program in a way that was not originally intended. The strategy of a hacker involves looking at a problem and thinking outside the box, trying to understand what the developer might not have considered and using this to the attacker’s advantage. Hacking can be used to manipulate software in two different ways. The first strategy is to find a “bug” that alters the behavior of the program and use this bug to take control over the program that is running, ultimately giving the attacker access to the system. The second strategy is taking advantage of a misconfiguration or poor programming practice, which is called configuration-related vulnerabilities. This occurs when a user sets a weak password or makes the system more unsecure in some way, and these vulnerabilities are easy to exploit and take advantage of. I also found it especially interesting to learn that there are “Bug Bounty Programs” that allow users to get paid for finding vulnerabilities in a company’s software and reporting these vulnerabilities to the company. This seems like it would be a fun way to make extra income on the side!  </p>
    <p>Hacking has become more prevalent and serious over time, specifically over the past forty to fifty years; however, there has been a shift in attacks over the last few years. In the past, the majority of attacks started from the internet and would target demilitarized zones (or perimeter networks), which are the physical or logical subnetwork that contains and exposes an organization’s external-facing services to an untrusted network, or border systems. For example, hackers would try to attack using a company’s website or email servers exposed to the internet. However, companies responded by starting to harden their perimeter by using firewalls and consistently updating patches to protect against these kinds of attacks. The result of this is that nowadays many attackers are shifting their focus from perimeter systems to users themselves using phishing and social engineering attacks. The attackers use these attacks because they know that the inside of a company’s perimeter does not have much segmentation or any sort of restriction, so if the attacker can compromise a user system, they can launch and attack from that user system out to the rest of the network. One method of executing this kind of attack is to target a user’s browser, with the attacker hacking the browser when the user navigates to a specific website. As the website renders, it triggers a condition within the browser itself, which allows the attacker to get control over both the browser and the computer to a certain extent.</p>
    <p>One major debugging tool used for exploits is WinDbg. WinDbg is a standard debugger that freezes the program to a certain extent so you can interact and inspect the various states of the program in a particular part of its execution. When using WinDbg for debugging, the first things that appear within the window are how the program has been run, all the modules that are being loaded, which breakpoints are set, the output of the registers, and where the user is running the program. There are several commands that are especially helpful with this tool. The “lm” command is used to see list modules, while the “lmf” command allows you to list all the modules and find the module that matches a certain string. You can set a breakpoint by using the “bp” command along with symbols that will allow the user to reference everything by the friendly function names rather than the memory addresses where all the functions are located. To view all breakpoints, you can use the command “bl”, which stands for “breakpoint list”. This command tells the user the memory address and some additional details. The command for “go” is “g”, which begins to execute the program until it hits a breakpoint, at which time the program stops running. When the program stops running it gives the status of all the registers when the breakpoint hit and where the user is executing from. The “dd” command displays a dword of memory, while the “db” command displays the actual view of bytes. The “u” command “unassembles” by taking all the bytes at the addresses and starting to process them as assembly. These commands comprise the basics of looking at memory instructions.</p>
    <p>On the other hand, the user can also use WinDbg commands to investigate strings in memory. With strings it is important to remember that a number in WinDbg is actually in hex, and it can be converted by using the .formats command. The “dv” command shows you what values are within the local variables currently, and the “db” command can show you the ASCII representation, which can contain strings. The “da” command goes a step further by showing you a specific value as an ASCII string. Five other common commands in this tool are “t” to take a single step into the program, “p” to step over within the program, “g” with an address value to view the place within the program with the values of all the registers, “pt” to execute until return, and “q” to quit. </p>
    <p>Registers and their values are crucial to debugging. Registers are essentially spots where a user’s CPU can store data, usually in very small amounts or dwords. Certain registers may have specific purposes, such as EAX for the return value of a function, EIP for where in memory the CPU is executing from, and EBP and ESP for setting the start and end of a stack frame. The “r” command within WinDbg is a useful way to view the values of all the registers. Investigating program memory is also essential to debugging. Two built-in extended commands within WinDbg that can facilitate this are !teb and !peb. !teb stands for the thread execution block, which provides you with the stack limit and the stack base. !peb stands for the process execution block, which provides you with the process heap, which is the default Windows heap. </p>
    <p>There are four main flaw classes and vulnerabilities: configuration, logic, storage, and input validation. These vulnerabilities can occur with weak passwords, authorization issues, inadequate encryption, memory corruption, and injection. Memory corruption is the process of accessing memory in an invalid way which results in an undefined behavior. It is often invoked through some sort of input, and it involves reading or writing stack or heap memory in a way that was originally unintended to gain control. The common categories of memory corruption are lifetime control, uninitialized memory, array index calculations, and buffer length calculations. The focus this week was on buffer length calculations, specifically stack overflows, which leads us into some background information about exploits.</p>
    <p>Exploits are defined as some code or input of data that you provide the program that will cause some condition. For example, a vulnerability trigger invokes a software bug to obtain control of a program, or controlling the crash of a program in a way that is beneficial to the attacker. A payload is the action to be performed when control is obtained, and this is traditionally called the “shell” code. The shell code is usually assembly code to execute a shell. For example, a calculator is typically used in demonstrations to signify that you can execute code on the system, which is proof that we can run any code we want. Metasploit, which is meant to aid professionals in performing security assessments, has several vulnerability triggers and payloads that can be utilized; however, these are fairly impractical in a real-world attack.</p>
    <p>When attempting to exploit vulnerabilities, it is essential to have knowledge of the structure and functions of the Stack. The Stack is a state mechanism that a program uses to know how to get back to its current state. Within a program stack, function parameters are passed to the main function, and when the main function is called, it saves the return address on the stack to know how to get back to that state. The registers that point to the start and end of the stack frame are the ESP and EBP registers, EBP being the register that is a base pointer pointing to the start of the stack frame and ESP being the register that keeps track of the top of the stack frame. From here, the function prologue occurs, saving the state where the function was previously, saving the EBP onto the stack, and then incrementing the ESP when something is added to the top of the stack. Space is then allocated on the stack for the local variables by subtracting, which causes the stack to grow toward lower addresses. The ESP increments and the EBP stays where it is. The function with its function parameters is then called, causing ESP to increment and pushing the return address onto the stack. Once the return address is saved, the ESP increments again, the EBP is saved, and the ESP increments once more. The teardown of this stack begins with ESP decrementing, the stored return address being taken off the stack and put into the instruction pointer (or the EIP register), return 4 taking the value, returning it to the EIP, and removing an additional 4 bytes off the stack, and then removing function parameters off the stack and decrementing the ESP. Within WinDbg, the “k” command can be used to view the call stack, which shows you where the child EBP is and the return address.</p>
    <p>A stack overflow refers to an unbounded copy, or copying with the user-provided length into a smaller buffer. This can be caused by calling the memcpy() function, copying the user-defined length into the buffer length, copying byte by byte into this buffer variable, and overwriting an area that controls the state of the program where the saved EBP is located. Stack overflows have the ability to overwrite basically everything on the stack, controlling the entire state of the program due to the fact that you have control over the return address, which allows you to have control over the path the program takes. After calling memcpy(), we can pop the EBP, taking the EBP off of the stack and copying it into a register so we can restore the previous stack frame. At this point the address is unallocated space that points to nothing. Return 4 then takes the value off the stack and tells the program to start executing at that address, which again is unallocated space. At this point we have gained control over the program. </p>
    <p>In order to execute code once this vulnerability is exploited there are several things we must do. For instance, we must determine the return address offset, or determine how big the buffer is. The end goal is to overwrite the EIP with something we can control. With commands like !load byakugan, we can automatically look at the registers and, using a non-repeated string, we can look at what offset each register was overwritten with using !pattern_offset. We must also position our shell code for execution by getting the shell code into the memory of the program to execute it. First, we must be able to find the address of our shell code, however, which can be difficult to figure out, as the stack layout could be different over different systems. Nevertheless, if we think about where we are in the execution flow, we can get a better idea of the location, as we know ESP points to the shell code after a return 4. One cool technique used to find the shell code is the Trampoline Technique. This technique looks for a special instruction by finding a module loaded at a static address, and then finding the “jmp esp” or similar instruction within that memory space. If we give x86 the address of the jmp esp instruction, or the ff e4 bytes, it will process it as a totally separate set of instructions. We can look for ff e4 anywhere in the program code or memory and replace the return address with that jmp esp instruction. This causes the program to jump to the shell code and start executing right off the stack because the ESP is pointing to the shell code afterwards. </p>
    <p>A simple process to execute code and exploit a vulnerability is finding the offset using !load byakugan and !pattern_offset, triggering the vulnerability by creating a string of a specific length (remembering the order of the Unicode text), finding the address to jmp esp in WinDbg and adding it to the string variable, and then adding the shell code into the string variable.  One thing to keep in mind is that return 4 changes the payload. When this instruction gets called, it can clean up the jmp esp instruction from the stack, which means we must give the stack 4 extra bytes to satisfy it and maintain our payload. </p>
    <p>Use-after-free exploitation involves allocating some sort of memory, freeing the memory, and then using them memory again, which could lead to exploitable conditions. There are four steps to use-after-free. The first step is freeing the object. Once the object is free, we can then replace the object with ours by first determining the size using something like the page heap, and then making allocations of the same size. After this allocation is made, we can position our shell code. Here, we can take advantage of the heap allocator with a Heap Spray. This involves allocating a huge amount of space and using VirtualAlloc(1MB) to request so much data that the data that is already there and being used gets pushed to the bottom and all the high memory addresses are allocated in a predictable way. Then we can say that the data will be at a certain high memory address. The last step is using the object again. </p>
    <p>To expand on this method, it is important to know more about the Heap. The Heap has many different layers. The operator new() method instantiates a new instance of a class, and calls a number of different heap APIs: malloc(), GlobalAlloc(), LocalAlloc(), and HeapAlloc(). The next layer is the front-end allocator for Windows, or the low fragmentation heap (LFH) for small data sizes in Windows 7. This may or may not be used depending on if the low-fragmentation heap is enabled or if it is available. The back-end allocator, which manages blocks with segments (FreeLists) is then called with the RtlAllocateHeap() allocator. The last layer is the memory manager with the VirtualAlloc() allocator. Depending on the size you choose to use for your data request, a specific allocator is chosen. </p>
    <p>The Default Process Heap is the heap that Internet Explorer uses. When a program is compiled with Microsoft’s Visual C Runtime library, it automatically gets 1 MB allocated for the Default Process Heap. When we make a request for 1 MB, it goes straight to VirtualAlloc(), which returns chunks of data. The Low-Fragmentation Heap is useful for browser exploitation. It can be enabled with JavaScript, and when you request an allocation of a small size, it creates a bucket for that size after the 18th allocation of that size. Page Heap is a useful tool, as it is a special “debugging” heap. It can be enabled via gflags, and it has the ability to give us all kinds of debugging information. This shows all of the information about the whole stack trace of the block being freed, including where it was freed and how it was freed. </p>
	    Screenshots from the materials this week are included in the following zip file: <a href="/Screenshots4.zip" download>Screenshots Week 4</a></p>
    </div>
  </div>
</div>

<div class="w3-col l4">
  <div class="w3-card w3-margin w3-margin-top">
    <div class="w3-container w3-white">
      <h4><b>Alexandra Carper</b></h4>
      <p>This page was created for Weekly Writeups for Defense Against the Dark Arts</p>
    </div>
  </div>
 
  

</div>

</div><br>

</div>

<footer>
</footer>

</body>
</html>
